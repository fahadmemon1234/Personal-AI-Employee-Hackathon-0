"""
Reasoning Loop Script
Detects requests in /Needs_Action, creates Plan.md with required checkboxes, and manages approval workflow
Implements the 'Ralph Wiggum' autonomous loop pattern with up to 5 iterations and stop hook strategy
"""

import os
import time
from pathlib import Path
from datetime import datetime
import json
import re
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()


class ReasoningLoop:
    """Implements the reasoning loop for processing requests in Needs_Action folder"""

    def __init__(self, needs_action_dir=None, approved_dir=None, completed_dir=None, plans_dir=None):
        self.needs_action_dir = Path(needs_action_dir or os.getenv("NEEDS_ACTION_DIR", "Needs_Action"))
        self.approved_dir = Path(approved_dir or os.getenv("APPROVED_DIR", "Approved"))
        self.completed_dir = Path(completed_dir or os.getenv("COMPLETED_DIR", "Completed"))
        self.plans_dir = Path(plans_dir or os.getenv("PLANS_DIR", "Plans"))
        self.loop_interval = int(os.getenv("REASONING_LOOP_INTERVAL", "10"))
        self.max_iterations = int(os.getenv("MAX_AUTONOMOUS_ITERATIONS", "5"))

        # Create directories if they don't exist
        self.needs_action_dir.mkdir(exist_ok=True)
        self.approved_dir.mkdir(exist_ok=True)
        self.completed_dir.mkdir(exist_ok=True)
        self.plans_dir.mkdir(exist_ok=True)

        # Track autonomous loop state
        self.autonomous_iterations = 0
        self.max_autonomous_iterations = self.max_iterations
        self.task_complete = False

    def scan_needs_action(self):
        """Scan the Needs_Action directory for new requests"""
        if not self.needs_action_dir.exists():
            print(f"Directory {self.needs_action_dir} does not exist")
            return []

        files = list(self.needs_action_dir.glob("*"))
        return files

    def read_file_content(self, file_path):
        """Read the content of a file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            # If UTF-8 fails, try with latin-1
            with open(file_path, 'r', encoding='latin-1') as f:
                return f.read()

    def generate_plan(self, request_file):
        """Generate a plan based on a single request found"""
        content = self.read_file_content(request_file)

        # Extract sender information if available in the file content
        sender_info = "Unknown Sender"
        # Look for common patterns that might indicate a sender
        lines = content.split('\n')
        for line in lines[:10]:  # Check first 10 lines for sender info
            if 'from:' in line.lower() or 'sender:' in line.lower():
                sender_info = line.strip()
                break

        # Generate a unique plan filename based on the request file
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        plan_filename = f"Plan_{request_file.stem}_{timestamp}.md"
        plan_path = self.plans_dir / plan_filename

        # Create plan content with required checkboxes
        plan_content = f"""# Action Plan for {request_file.name}

Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Request Details
- **Request File**: {request_file.name}
- **Sender**: {sender_info}
- **Content Preview**:
  ```
  {content[:300] + '...' if len(content) > 300 else content}
  ```

## Action Items
- [ ] **Identify the sender** - {sender_info}
- [ ] **Draft a reply** - Need to create appropriate response
- [ ] **Request approval for sensitive actions** - Check if this requires special approval

## Next Steps
1. Analyze the request content
2. Determine appropriate response
3. Follow human-in-the-loop pattern for any outgoing messages
4. Update status when completed

---
*This plan was automatically generated by the Reasoning Loop*
"""

        # Write the plan to the Plans directory
        with open(plan_path, 'w', encoding='utf-8') as f:
            f.write(plan_content)

        # Add link to the plan in Dashboard.md under "Current Active Plans"
        self.add_plan_link_to_dashboard(plan_path)

        print(f"Plan created: {plan_path}")
        return plan_path

    def add_plan_link_to_dashboard(self, plan_path):
        """Add a link to the newly created plan in Dashboard.md under 'Current Active Plans'"""
        dashboard_path = Path("Dashboard.md")

        # Read the current dashboard content
        if dashboard_path.exists():
            with open(dashboard_path, 'r', encoding='utf-8') as f:
                dashboard_content = f.read()
        else:
            # If dashboard doesn't exist, create a basic one
            dashboard_content = "# AI Agent Dashboard\n\n## Current Active Plans\n\n"

        # Check if "Current Active Plans" section exists
        if "## Current Active Plans" not in dashboard_content:
            # If not, add the section after the main header
            lines = dashboard_content.split('\n')
            lines.insert(1, "\n## Current Active Plans\n")  # Insert after first line
            dashboard_content = '\n'.join(lines)

        # Create the link to the plan
        plan_name = plan_path.name
        plan_link = f"- [{plan_name}]({plan_path})\n"

        # Check if this plan link already exists in the dashboard
        if plan_link.strip() in dashboard_content:
            # Plan link already exists, no need to add it again
            return

        # Find the "Current Active Plans" section and add the link
        lines = dashboard_content.split('\n')
        new_lines = []
        added = False

        for line in lines:
            new_lines.append(line)
            if line.startswith("## Current Active Plans") and not added:
                # Add the plan link as the next line
                new_lines.append(plan_link)
                added = True

        # Write the updated dashboard content
        with open(dashboard_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(new_lines))

    def has_approval(self):
        """Check if there's an approval file in the Approved directory"""
        approval_files = list(self.approved_dir.glob("*"))
        return len(approval_files) > 0

    def process_approved_requests(self):
        """Process requests after approval is given"""
        if not self.has_approval():
            print("No approval found. Waiting for approval...")
            return False

        request_files = self.scan_needs_action()
        if not request_files:
            print("No requests to process.")
            return True

        print(f"Processing {len(request_files)} approved requests...")

        for file_path in request_files:
            print(f"Processing: {file_path.name}")

            # Determine what kind of request this is and process accordingly
            content = self.read_file_content(file_path)

            # Check if this requires human-in-the-loop for outgoing messages
            if self.requires_human_approval(content):
                # Create a draft for human approval before sending any outgoing message
                self.create_outgoing_message_draft(file_path, content)
                print(f"Created draft for human approval: {file_path.name}")
            else:
                # Process directly if no human approval needed
                completed_path = self.completed_dir / file_path.name
                file_path.rename(completed_path)
                print(f"Moved {file_path.name} to {completed_path}")

        # Clear approval files after processing
        for approval_file in self.approved_dir.glob("*"):
            approval_file.unlink()
            print(f"Removed approval file: {approval_file.name}")

        print("All approved requests processed.")
        return True

    def requires_human_approval(self, content):
        """Determine if content requires human approval before sending outgoing message"""
        # Define keywords that indicate sensitive actions requiring human approval
        sensitive_keywords = [
            'urgent', 'important', 'contract', 'payment', 'money', 'financial',
            'legal', 'agreement', 'offer', 'proposal', '$', 'price', 'cost',
            'personal', 'confidential', 'private', 'sensitive'
        ]

        content_lower = content.lower()
        return any(keyword in content_lower for keyword in sensitive_keywords)

    def create_outgoing_message_draft(self, request_file, content):
        """Create a draft outgoing message that requires human approval"""
        # Create Pending_Approval directory if it doesn't exist
        pending_dir = Path("Pending_Approval")
        pending_dir.mkdir(exist_ok=True)

        # Generate a draft response based on the request
        draft_content = self.generate_response_draft(content)

        # Create a draft file in Pending_Approval
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        draft_filename = f"draft_response_{request_file.stem}_{timestamp}.txt"
        draft_path = pending_dir / draft_filename

        with open(draft_path, 'w', encoding='utf-8') as f:
            f.write(f"Original Request:\n{content}\n\n---\n\nDraft Response:\n{draft_content}")

        print(f"Created draft response for approval: {draft_path}")

        # Also update the corresponding plan to indicate human approval is needed
        self.update_plan_for_human_approval(request_file)

    def generate_response_draft(self, content):
        """Generate a draft response based on the incoming request"""
        # Simple response generation - in a real implementation, this could use AI
        response_templates = [
            "Thank you for your message. We have received your request and will review it shortly.",
            "We appreciate you reaching out. Our team will evaluate your inquiry and respond accordingly.",
            "Your request has been noted. We will get back to you with more information soon.",
            "Thanks for contacting us. We're currently reviewing your message and will provide an update shortly."
        ]

        # Choose a template based on content characteristics
        if any(word in content.lower() for word in ['urgent', 'asap', 'immediately']):
            return "We have received your urgent request and are prioritizing it. Expect a response within 24 hours."
        elif any(word in content.lower() for word in ['question', 'help', 'support']):
            return "Thank you for your inquiry. We're looking into your question and will provide assistance shortly."
        else:
            import random
            return random.choice(response_templates)

    def update_plan_for_human_approval(self, request_file):
        """Update the corresponding plan to indicate human approval is needed"""
        # Find the most recent plan for this request
        plan_pattern = f"Plan_{request_file.stem}_*.md"
        matching_plans = list(self.plans_dir.glob(plan_pattern))

        if matching_plans:
            # Get the most recently created plan
            latest_plan = max(matching_plans, key=os.path.getctime)

            # Read the current plan
            with open(latest_plan, 'r', encoding='utf-8') as f:
                plan_content = f.read()

            # Add a note about human approval being required
            if "requires human approval" not in plan_content.lower():
                plan_content += f"\n\n## Human Approval Required\n- [ ] Review and approve the draft response\n- [ ] Send final response\n\n*Note: This request requires human review before sending any outgoing message.*\n"

                # Write the updated plan back
                with open(latest_plan, 'w', encoding='utf-8') as f:
                    f.write(plan_content)

                print(f"Updated plan with human approval requirement: {latest_plan}")

    def check_task_completion(self, plan_path):
        """Check if the task is complete by looking for the TASK_COMPLETE promise tag"""
        if plan_path and plan_path.exists():
            with open(plan_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
                # Look for the TASK_COMPLETE promise tag
                if '<promise>TASK_COMPLETE</promise>' in content:
                    print(f"Task completion detected in {plan_path.name}")
                    self.task_complete = True
                    return True
        return False

    def self_fix_error(self, error_message):
        """Attempt to self-fix errors using logs and known patterns"""
        print(f"Attempting to self-fix error: {error_message}")
        
        # Log the error for debugging
        error_log_path = Path("error_log.txt")
        with open(error_log_path, 'a', encoding='utf-8') as f:
            f.write(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error: {error_message}\n")
        
        # Implement basic self-fix strategies based on error type
        if "Permission denied" in error_message:
            print("Permission error detected - checking file permissions...")
            # In a real implementation, you might adjust permissions here
            return True
        elif "File not found" in error_message:
            print("File not found error - checking if directory exists...")
            # Recreate missing directories
            self.needs_action_dir.mkdir(exist_ok=True)
            self.approved_dir.mkdir(exist_ok=True)
            self.completed_dir.mkdir(exist_ok=True)
            self.plans_dir.mkdir(exist_ok=True)
            return True
        elif "Connection refused" in error_message or "network" in error_message.lower():
            print("Network error detected - will retry on next iteration...")
            return True
        else:
            print("Unknown error type - logged for review")
            return False

    def run_ralph_wiggum_loop(self):
        """Run the Ralph Wiggum autonomous loop with up to 5 iterations and stop hook strategy"""
        print("Starting Ralph Wiggum Autonomous Loop...")
        print(f"Maximum iterations: {self.max_autonomous_iterations}")
        print("Will stop only when <promise>TASK_COMPLETE</promise> tag is found")

        while self.autonomous_iterations < self.max_autonomous_iterations and not self.task_complete:
            try:
                print(f"\n--- Iteration {self.autonomous_iterations + 1} ---")
                
                # Scan for new requests
                request_files = self.scan_needs_action()

                if request_files:
                    print(f"Found {len(request_files)} requests in Needs_Action")

                    # Generate a plan for each request file
                    for request_file in request_files:
                        plan_path = self.generate_plan(request_file)
                        
                        # Check if task is complete after generating plan
                        if self.check_task_completion(plan_path):
                            print("Task completion detected. Exiting loop.")
                            break

                    # Check for approval and process if approved
                    if self.has_approval():
                        print("Approval detected. Processing requests...")
                        self.process_approved_requests()
                    else:
                        print("Requests found. Plans created and waiting for approval.")
                else:
                    print("No requests in Needs_Action. Continuing autonomous loop...")

                # Increment iteration counter
                self.autonomous_iterations += 1
                
                # Check if we've reached the max iterations
                if self.autonomous_iterations >= self.max_autonomous_iterations:
                    print(f"Reached maximum iterations ({self.max_autonomous_iterations}). Stopping loop.")
                    break
                
                # Wait before next iteration
                time.sleep(self.loop_interval)  # Check every N seconds (from env)

            except KeyboardInterrupt:
                print("\nRalph Wiggum Loop interrupted by user.")
                break
            except Exception as e:
                error_msg = str(e)
                print(f"Error in Ralph Wiggum loop: {error_msg}")
                
                # Attempt to self-fix the error
                if self.self_fix_error(error_msg):
                    print("Self-fix attempt completed. Continuing loop...")
                    continue
                else:
                    print("Self-fix failed. Reporting error and continuing loop...")
                    # Continue the loop even after error, as per requirements
                    continue

        print(f"\nRalph Wiggum Loop completed after {self.autonomous_iterations} iterations")
        if self.task_complete:
            print("Task completion detected via <promise>TASK_COMPLETE</promise> tag")
        else:
            print("Loop ended due to reaching maximum iterations or other condition")

    def run_reasoning_loop(self):
        """Run the main reasoning loop (original behavior)"""
        print("Starting Reasoning Loop...")

        while True:
            try:
                # Scan for new requests
                request_files = self.scan_needs_action()

                if request_files:
                    print(f"Found {len(request_files)} requests in Needs_Action")

                    # Generate a plan for each request file
                    for request_file in request_files:
                        self.generate_plan(request_file)

                    # Check for approval and process if approved
                    if self.has_approval():
                        print("Approval detected. Processing requests...")
                        self.process_approved_requests()
                    else:
                        print("Requests found. Plans created and waiting for approval.")
                else:
                    print("No requests in Needs_Action. Waiting...")

                # Wait before next iteration
                time.sleep(self.loop_interval)  # Check every N seconds (from env)

            except KeyboardInterrupt:
                print("\nReasoning Loop interrupted by user.")
                break
            except Exception as e:
                print(f"Error in reasoning loop: {e}")
                time.sleep(10)  # Wait before retrying


def main():
    """Main function to run the reasoning loop"""
    print("Initializing Reasoning Loop with Ralph Wiggum Autonomous Pattern...")

    # Initialize the reasoning loop
    loop = ReasoningLoop()

    # Run the Ralph Wiggum autonomous loop
    loop.run_ralph_wiggum_loop()


if __name__ == "__main__":
    main()